{
  "hash": "93e0beba038fe65807901b8bd572cff2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Punctuation and Other Problems\"\nauthor: \"Kelly Bodwin\"\ndate: \"2025-04-24\"\ndraft: false\ncategories: [random, nse]\nimage: \"error.png\"\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: \"#>\" \nexecute:\n  error: true\n  message: false\n---\n\n\n\nI'm doing some mentoring for [Posit Academy](https://posit.co/products/enterprise/academy/)'s \"Programming in R\" course, and the learners in my group have been asking very clever and deep questions about how to use Non-Standard Eval in R functions.\n\nSpecifically, the thing that keeps cropping up that I haven't been able to answer in a satisfying way is **iterating through unquoted input**.\n\n[This blog post from Albert Rapp](https://albert-rapp.de/posts/03_writing_versatile_fcts/03_writing_versatile_fcts) is excellent pre-reading. \n\n## tl;dr\n\nBy request, I'm putting the final conclusions up front here for easy reference.\n\n![](https://media4.giphy.com/media/Zsxh9Cbq7VCy4/giphy.gif?cid=6c09b9520g12equqlkshk2pj8igt3zf8drgbbileoa6cfjrx&ep=v1_gifs_search&rid=giphy.gif&ct=g)\n\n**To `map()` over unquoted names:**\n\nThe trick here is you need `quos()` to keep `map()` from triggering the unquoted code, and then you need tunneling (`{{x}}`) in the anonyous function as you would in any function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(quos(c(vs, am, gear, carb)),\n    \\(x) some_function(mtcars, {{x}}))\n```\n:::\n\n\n\n\n**To pass the dots (`...`) into `across()`:**\n\nFirst you need `enquos(...)` to defuse the dots. \n\nThe sneaky bit in this one is that `across()` wants a vector of unquoted column names to use, and `enquos()` returns a list.\n\nSo, we splice the list into separate arguments with `!!!` and re-concatenate them with `c()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo_stuff <- fucntion(data, ...) {\n    \n    args <- enquos(...)\n\n    data |>\n        summarize(across(c(!!!args), some_function))\n\n}\n```\n:::\n\n\n\nRead on to see an example, with the many things I tried that **didn't** work, why they didn't work, and how I fixed it.\n\n## Set the scene\n\nFor the sake of example, let's suppose the task I want to do is count how many ones are in a particular column.\n\nI've written a nice function, using tunneling (`{{}}`) to run on unquoted variable names.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ncount_ones <- function(data, var) {\n  \n  data |>\n    summarize(\n      n_ones = sum({{var}} == 1)\n    ) |>\n    pull(n_ones)\n  \n}\n\ncount_ones(mtcars, vs)\n#> [1] 14\n```\n:::\n\n\n\nFabulous.  We could clean this output up a bit, but we won't, because lazy.\n\nSo, the question is, what if I want to do this to multiple columns at once?\n\n\n## Option 1: mapping\n\nThe challenge here lies in the fact that if we put unquoted variable names into the `map()` function, the code \"triggers\" before it \"gets to\" the `count_ones()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(vs, am, gear, carb), \n    \\(x) count_ones(mtcars, x))\n#> Error: object 'vs' not found\n```\n:::\n\n\n\nOne solution is to fall back onto strings for the `map()` input and then re-unquote-ify them for use in `count_ones()`, which is highly unsatisfying.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(\"vs\", \"am\", \"gear\", \"carb\"), \n    \\(x) count_ones(mtcars, !!sym(x)))\n#> [[1]]\n#> [1] 14\n#> \n#> [[2]]\n#> [1] 13\n#> \n#> [[3]]\n#> [1] 0\n#> \n#> [[4]]\n#> [1] 7\n```\n:::\n\n\n\nIt's not terrible but the `!!sym(x)` is far from intuitive.  I always read `!!` as \"access the information stored in\" and `sym` as \"turn this from a string to a name\".  So, it kind of makes sense - we hand a string to `count_ones()` but first we say \"Don't use this string, instead access the information in the name of the string.\"\n\nI'm still convinced there's a better way, though.  Or at least, a different way.\n\nWhat I want to do is find a way to \"freeze\" the unquoted variable names so they can be passed into `count_ones()`.\n\nMy first thought was to use `quos()`.  Here's now I understand these functions:\n\n* `quo()` = freeze this one unquoted thing\n\n* `quos()` = freeze this vector of unquoted things\n\n* `enquo()` = freeze this unquoted function argument\n\n* `enquos()` = frees this vector of unquoted function arguments\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(quos(c(vs, am, gear, carb)),\n    \\(x) count_ones(mtcars, x))\n#> Error in `map()`:\n#> ℹ In index: 1.\n#> Caused by error in `summarize()`:\n#> ℹ In argument: `n_ones = sum(x == 1)`.\n#> Caused by error:\n#> ! Base operators are not defined for quosures. Do you need to unquote\n#>   the quosure?\n#> \n#> # Bad: myquosure == rhs\n#> \n#> # Good: !!myquosure == rhs\n```\n:::\n\n\n\nWait, this is great!  The error is being triggered in `sum()` inside of `count_ones()`, not inside of `map()`. So we did freeze it.\n\nThe error message suggests that I need to use `!!` inside of `count_ones()` to \"unfreeze\".  I'm skeptical, because I don't want to unfreeze `x`; I want to access the name `vs`.  Also my goal is not to modify that function.  \n\nInstead I think this might just be a missed tunneling, so that the frozen column names get passed through my anonymous function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(quos(c(vs, am, gear, carb)),\n    \\(x) count_ones(mtcars, {{x}}))\n#> [[1]]\n#> [1] 34\n```\n:::\n\n\n\n\nDang I really thought that would work, but it appears that by using `quos()`, I've accidentally frozen the whole vector together and counted everything in all columns. Which, honestly, is kind of cool - but not what I meant to do.\n\nI really don't want to have to `quo()` each individual column name.\n\nLet me take a look a this output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquos(c(vs, am, gear, carb))\n#> <list_of<quosure>>\n#> \n#> [[1]]\n#> <quosure>\n#> expr: ^c(vs, am, gear, carb)\n#> env:  global\n```\n:::\n\n\n\nOkay so it froze the whole expression.  Maybe we just don't want the `c()`, because `quos()` is already concatenating?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquos(vs, am, gear, carb)\n#> <list_of<quosure>>\n#> \n#> [[1]]\n#> <quosure>\n#> expr: ^vs\n#> env:  global\n#> \n#> [[2]]\n#> <quosure>\n#> expr: ^am\n#> env:  global\n#> \n#> [[3]]\n#> <quosure>\n#> expr: ^gear\n#> env:  global\n#> \n#> [[4]]\n#> <quosure>\n#> expr: ^carb\n#> env:  global\n```\n:::\n\n\n\nThis is promising!  A list of quosures is what we want!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(quos(vs, am, gear, carb),\n    \\(x) count_ones(mtcars, {{x}}))\n#> [[1]]\n#> [1] 14\n#> \n#> [[2]]\n#> [1] 13\n#> \n#> [[3]]\n#> [1] 0\n#> \n#> [[4]]\n#> [1] 7\n```\n:::\n\n\n![I am pleased with this solution.](https://media.tenor.com/aMt8y3umPPAAAAAM/will-smith-victory.gif)\n\n\n## Option 2: Pass the dots\n\nThe other clever approach one of my learners took was to rewrite the original function to accept the variable names in the dots (`...`).\n\nThis works great if you are just sending the variable names along to the next internal function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_all <- function(data, ...) {\n  \n  data |>\n    select(...) |>\n    head()\n  \n}\n\nselect_all(mtcars, vs, am, gear, carb)\n#>                   vs am gear carb\n#> Mazda RX4          0  1    4    4\n#> Mazda RX4 Wag      0  1    4    4\n#> Datsun 710         1  1    4    1\n#> Hornet 4 Drive     1  0    3    1\n#> Hornet Sportabout  0  0    3    2\n#> Valiant            1  0    3    1\n```\n:::\n\n\n\nHowever, of course, this does not just slot in to our function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ncount_ones <- function(data, ...) {\n  \n  data |>\n    summarize(\n      n_ones = sum(... == 1)\n    ) |>\n    pull(n_ones)\n  \n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#> Error in `summarize()`:\n#> ℹ In argument: `n_ones = sum(... == 1)`.\n#> Caused by error:\n#> ! object 'vs' not found\n```\n:::\n\n\nThe tidy approach to doing something to many columns is to use `across()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n  mtcars |>\n    summarize(\n      across(c(vs, am, gear, carb),\n            ~sum(.x == 1)\n    ))\n#>   vs am gear carb\n#> 1 14 13    0    7\n```\n:::\n\n\n\n\nBut inside of a function, this fails:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n  \n  mtcars |>\n    summarize(\n      across(...,\n            ~sum(.x == 1)\n    ))\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#> Error in `summarize()`:\n#> ℹ In argument: `across(..., ~sum(.x == 1))`.\n#> Caused by error in `across()`:\n#> ! Can't compute column `vs`.\n#> Caused by error:\n#> ! object 'gear' not found\n```\n:::\n\n\n\nI surmise this is an arguments problem: `across()` expects a single argument, which is a vector of the column names, while the dots are passing the inputs along as four separate arguments.\n\nMy first instinct was to use `dots_list()` to smush the dots inputs into a single list object to hand to `across()`.  But this fails for perhaps predictable reasons:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n  \n  args <- dots_list(...)\n  \n  mtcars |>\n    summarize(\n      across(args,\n            ~sum(.x == 1)\n    ))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#> Error: object 'vs' not found\n```\n:::\n\n\n\nYe Olde NSE strikes again: `dots_list()` is triggering the unquoted names to be evaluated, so `vs` not found.\n\nWell, we did just learn that `quos()` will get us a list of quosures, so let's hit the dots with that:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n  \n  args <- enquos(...)\n  \n  mtcars |>\n    summarize(\n      across(args,\n            ~sum(.x == 1)\n    ))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#> Error in `summarize()`:\n#> ℹ In argument: `across(args, ~sum(.x == 1))`.\n#> Caused by error in `across()`:\n#> ! Can't select columns with `args`.\n#> ✖ `args` must be numeric or character, not a <quosures/list> object.\n```\n:::\n\n\n\nAlright, so `across()` can't handle a list.  One thing we could definitely do at this point is just move our `map()` approach to inside of the function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n  \n  args <- enquos(...)\n  \n  map(args,\n      \\(x) count_ones(mtcars, {{x}}))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n```\n:::\n\n\n\nFriends. I did not mean to put `count_ones` inside of itself. The above code fully crashed my R Session, with this delightful error.\n\n![Please enjoy my hilarious failure.](error.png)\n\n\n![Tunneling has consequences.](https://y.yarn.co/90141801-b717-47b2-9498-09ba42d22fa5_text.gif)\n\nLet's try this again.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ncount_ones <- function(data, ...) {\n  \n  args <- enquos(...)\n  \n  map(args,\n      \\(x) \n      mtcars |>\n        summarize(\n          n_ones = sum({{x}} == 1)\n          ) |>\n        pull(n_ones))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#> [[1]]\n#> [1] 14\n#> \n#> [[2]]\n#> [1] 13\n#> \n#> [[3]]\n#> [1] 0\n#> \n#> [[4]]\n#> [1] 7\n```\n:::\n\n\n\n\n\nI'm tired and this is getting long ...but I still really want to defeat the `across()` problem, because the `...` + `across()` seems like an extremely handy construct.\n\nThere is one \"free\" solution, which is to just reduce our dataset to the columns we care about, and then tell `across()` to apply to `everything()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n\n  mtcars |>\n    select(...) |>\n    summarize(\n      across(everything(),\n            ~sum(.x == 1)\n    ))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#>   vs am gear carb\n#> 1 14 13    0    7\n```\n:::\n\n\n\n\nThis would probably be fine for every use case I can think of.  But it's not *technically* the same as using `across()` directly, because if you use `across()` inside `mutate()` it will keep all the other columns.\n\n\n### Exhibit A:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  mtcars |>\n    mutate(\n      across(c(vs, am, gear, carb),\n             sqrt)\n    ) |>\n  head()\n#>                    mpg cyl disp  hp drat    wt  qsec vs am     gear     carb\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1 2.000000 2.000000\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1 2.000000 2.000000\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1 2.000000 1.000000\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0 1.732051 1.000000\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0 1.732051 1.414214\n#> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0 1.732051 1.000000\n```\n:::\n\n\n\n\n### Exhibit B:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  mtcars |>\n    select(vs, am, gear, carb) |>\n    mutate(\n      across(everything(),\n            sqrt\n    )) |>\n  head()\n#>                   vs am     gear     carb\n#> Mazda RX4          0  1 2.000000 2.000000\n#> Mazda RX4 Wag      0  1 2.000000 2.000000\n#> Datsun 710         1  1 2.000000 1.000000\n#> Hornet 4 Drive     1  0 1.732051 1.000000\n#> Hornet Sportabout  0  0 1.732051 1.414214\n#> Valiant            1  0 1.732051 1.000000\n```\n:::\n\n\n\nTeam, we gotta crack this so I can go to bed.  Let's take stock:\n\n* We know how to \"freeze\" the variable names from the dots into a list of quosures with `enquos()`\n\n* We need to find a way to pass that information as a *vector* object to `across()`.\n\n![](https://y.yarn.co/83edfb01-843c-4a84-bae8-81b2ba0b390c_text.gif)\n\nSince this is a post about punctuation, let's bring in the big guns:  the TRIPLE BANG!!!\n\nThis guy `!!!` is one of my all time favorite tricks.  It lets you turn a list of things into separate function arguments, which is called *splicing*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs <- quos(vs, am, gear, carb)\n\n## won't work, because it looks for the column named 'args'\nmtcars |>\n  select(args) |>\n  head()\n#> Error in `select()`:\n#> ! Can't select columns with `args`.\n#> ✖ `args` must be numeric or character, not a <quosures/list> object.\n\n## will work, because it splices the contents of the `args` vector into separate inputs to select\nmtcars |>\n  select(!!!args) |>\n  head()\n#>                   vs am gear carb\n#> Mazda RX4          0  1    4    4\n#> Mazda RX4 Wag      0  1    4    4\n#> Datsun 710         1  1    4    1\n#> Hornet 4 Drive     1  0    3    1\n#> Hornet Sportabout  0  0    3    2\n#> Valiant            1  0    3    1\n```\n:::\n\n\n\n\nThe bad news:  What we want here is the *opposite* of splicing: we want our *list* of quosures to become a *vector* of quosures.\n\nThe good news: If only we had a function that takes multiple arguments and *concatenates* them into a vector....\n\n![Actually, c() is for concatenate.](https://media2.giphy.com/media/NFpfxyP7jm1Q4/200w.gif?cid=6c09b95288507gct7uf158ysohurcndij8y7npnn7614ypqj&ep=v1_gifs_search&rid=200w.gif&ct=g)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_ones <- function(data, ...) {\n  \n  args <- enquos(...)\n  \n  data |>\n    summarize(\n      across(c(!!!args),\n            ~sum(.x == 1)\n    ))\n\n}\n\ncount_ones(mtcars, vs, am, gear, carb)\n#>   vs am gear carb\n#> 1 14 13    0    7\n```\n:::\n\n\n\n\nBoom! It still feels a little annoying to me that we had to *freeze - splice - concatenate*, that feels like too many steps, but I'll take it.   I can go to bed unfrustrated!\n\nThus ends my stream-of-consciousness journey into NSE.  If you came along with me this far, thanks for hanging out, and let me know if there is any `rlang` trickery that I missed!\n\n![](https://i.imgur.com/sbTj8UB.gif)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}