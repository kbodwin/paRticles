{
  "hash": "e30c00dc2a7824ccfc812a164f33bfad",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"1-D Illustration of LDA vs QDA\"\nauthor: \"Kelly Bodwin\"\ndate: \"2024-07-20\"\ncategories: [code, analysis, packages]\nimage: \"./gganim_plot001.png\"\n---\n\n\nSo, three things happened this week that inspired this tidbit:\n\n* I learned about the [{distributional} package](https://github.com/mitchelloharawild/distributional) by ... at [the UseR 2024 conference](https://events.linuxfoundation.org/user/), which basically defines distributions as their own objects, to be plotted or used in calculations.  Very cool!\n\n* I was reminded in a conversation recently that [{gganimate}](https://gganimate.com/) is cool and something I'd like to use more in classes.\n\n* A student asked me why QDA can lead to circular boundaries and LDA can't, when the only difference is whether we let the covariance vary by group.  I answered by very badly drawing a series of pictures in the 1-D case.\n\nSo my goal here is to re-create those pictures as a gif.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(distributional)\nlibrary(gganimate)\n```\n:::\n\n\nAlright, first thing is to figure out plotting two normal distributions using `{distributional}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dists <- c(dist_normal(mu = 0, sigma = 1), \n              dist_normal(mu = 3, sigma = 1))\n\nmy_dists\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<distribution[2]>\n[1] N(0, 1) N(3, 1)\n```\n\n\n:::\n:::\n\n\n**DISTRIBUTIONS AS OBJECTS** my people I am so pleased with this structure.\n\nOkay hang on apparently we need [`ggdist`](https://mjskay.github.io/ggdist/) too to plot it... whoa I don't think I realized how awesome and built-out `ggdist` is.\n\nAnyways now it's super easy...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdist)\n\nggplot(my_dists) +\n  stat_dist_halfeye(aes(dist = dist))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `fortify()`:\n! `data` must be a <data.frame>, or an object coercible by `fortify()`,\n  or a valid <data.frame>-like object coercible by `as.data.frame()`.\nCaused by error in `.prevalidate_data_frame_like_object()`:\n! `dim(data)` must return an <integer> of length 2.\n```\n\n\n:::\n:::\n\n\nOOPS, famous last words.  Of course my objects still need to be in a data frame... duh, Kelly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  dist = c(dist_normal(mu = 0, sigma = 1), \n              dist_normal(mu = 3, sigma = 1))\n)\n\n\nggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dist))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nOkay cool but it's sideways and also I need colors.\n(Side note, it's annoying that \"distribution\" and \"distance\" are both super common stat words and they have the same natural abbreviation. Rabble rabble.)\n\nA little noodling and cheating with coord flip (there was probably a better way to get these on the x-axis) and I have what I want for now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  dist = c(dist_normal(mu = 0, sigma = 1), \n              dist_normal(mu = 3, sigma = 1)),\n  name = c(\"Class A\", \"Class B\")\n)\n\n\nggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dist,\n                        fill = name),\n                    alpha = 0.5) +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nNow we add the lines to show where the decision boundary for LDA would be (assuming equal prior probs here):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dist,\n                        fill = name),\n                    alpha = 0.5) +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  geom_hline(yintercept = 1.5) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\nI kinda feel like I should be able to use `geom_vline` after `coord_flip` and have it not get flipped because it comes as a later layer.  Rabble, rabble.\n\nAnyhoo.  Now to animate.\n\nThis is a little weird to think about because `gganimate` wants to step through \"state\" or values in the data.  I think I maybe want to set it up as two separate layers, one with the static blue curve and one with the moving red ones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  means = (-8:8)/2,\n  dists = dist_normal(mu = means, sigma = 1),\n)\n\nggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dists),\n                    alpha = 0.5,\n                    fill = \"#F8766D\") +\n  stat_dist_halfeye(aes(dist = dist_normal(mu = 0, sigma = 1)),\n                    alpha = 0.5,\n                    fill = \"#00BFC4\") +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  geom_hline(aes(yintercept = (means)/2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in layer_slabinterval(data = data, mapping = mapping, stat = StatSlabinterval, : All aesthetics have length 1, but the data has 17 rows.\nℹ Please consider using `annotate()` or provide this layer with data containing\n  a single row.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNow I gotta remember how you gganimate a plot.  I think you add a layer with some kind of `animate_` function?\n\n![](https://s3.us-west-1.wasabisys.com/idbwmedia.com/images/2012/08/rtfmtractor.jpg)\n\nOk cool got it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim <-\n  ggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dists),\n                    alpha = 0.5,\n                    fill = \"#F8766D\") +\n  stat_dist_halfeye(aes(dist = dist_normal(mu = 0, sigma = 1)),\n                    alpha = 0.5,\n                    fill = \"#00BFC4\") +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  geom_hline(aes(yintercept = (means)/2)) +\n  transition_manual(means)\n\nanimate(anim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.gif)\n:::\n:::\n\n\nEt voila!  What we're seeing here is that if the curves have the same variance, they can only ever cross at one point.  (Well, unless they have the *exact* same mean and have infinite overlap, but if that's the case then LDA is pointless anyways.)\n\n\nSo now what if we let them have different variances?  We'll try one for starters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  means = -1,\n  dists = dist_normal(mu = means, sigma = 3),\n)\n\nggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dists),\n                    alpha = 0.5,\n                    fill = \"#F8766D\") +\n  stat_dist_halfeye(data = NULL, aes(dist = dist_normal(mu = 0, sigma = 1)),\n                    alpha = 0.5,\n                    fill = \"#00BFC4\") +\n  scale_thickness_shared() +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nOkay `scale_thickness_shared()` ended up being really important here to keep the curves from being the same height (and thus different areas, ew).\n\nFinding the intersection point is more of a pain than I thought about at first, because Normal equations are not really closed-form solvable.  But `distributional` makes this not TOO bad at least.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  means = (-8:8)/2,\n  dists = dist_normal(mu = means, sigma = 3),\n)\n\nstd_normal <- dist_normal(mu = 0, sigma = 1)\n\ngrid <- seq(-10, 10, 0.1)\nstd_dens <- density(std_normal, grid)[[1]]\n\ncrosslines <-\n  my_df$dists |>\n  density(grid) |>\n  map(\\(dens) order(abs(dens/std_dens - 1))[1:2]) |>\n  map(\\(idx) sort(grid[idx])) |>\n  reduce(rbind)\n\nmy_df <- \n  my_df |>\n  mutate(\n    lower = crosslines[,1],\n    upper = crosslines[,2]\n  )\n```\n:::\n\n\nPhew.  That took some doing actually.\n\nBUT!  The part you should be excited about here is `my_df$dists |> density(grid)`.  Like.... that vectorization is elegant af.\n\nAnyways.  Cool.  Here's a gif.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim <-\n  ggplot(my_df) +\n  stat_dist_halfeye(aes(dist = dists),\n                    alpha = 0.5,\n                    fill = \"#F8766D\") +\n  stat_dist_halfeye(data = NULL, aes(dist = dist_normal(mu = 0, sigma = 1)),\n                    alpha = 0.5,\n                    fill = \"#00BFC4\") +\n  scale_thickness_shared() +\n  coord_flip() +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  geom_hline(aes(yintercept = lower)) +\n  geom_hline(aes(yintercept = upper)) +\n  transition_manual(means)\n\nanimate(anim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.gif)\n:::\n:::\n\n\nBoom!  Two points of intersection, which lets you segment the space such that blue class is \"inside\" and red class is \"outside\".\n\nIf you can mental-image this up to two dimensions, maybe you can see how equal-variance bell curves intersect at a straight line, and nonequal-variance onces can have an \"inner circle\" and \"outer circle\", hence LDA vs QDA.\n\nThe end!\n\nIf I were using this in class, I'd probably add:\n\n* Some sample observations, to show that in LDA/QDA these curves are the estimates we get based on observed data, not something we magically know ahead of time.\n\n* Some background coloring or arrows or something to clarify that the boundaries are prediction boundaries; we predict red or blue class based on where a new observation lands.\n\n* Some aesthetic dressing up: Nice outlines on the curves, a star or something at the density intersection, better colors than red-blue, etc.\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}